# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

vectorize <- function(mat, axis) {
    .Call('rarhsmm_vectorize', PACKAGE = 'rarhsmm', mat, axis)
}

colsum <- function(matrix) {
    .Call('rarhsmm_colsum', PACKAGE = 'rarhsmm', matrix)
}

rowsum <- function(matrix) {
    .Call('rarhsmm_rowsum', PACKAGE = 'rarhsmm', matrix)
}

subsetmatrix <- function(rawmat, rowindex, colindex) {
    .Call('rarhsmm_subsetmatrix', PACKAGE = 'rarhsmm', rawmat, rowindex, colindex)
}

matrixpower <- function(oldmat, power) {
    .Call('rarhsmm_matrixpower', PACKAGE = 'rarhsmm', oldmat, power)
}

matrixexp <- function(oldmat, t) {
    .Call('rarhsmm_matrixexp', PACKAGE = 'rarhsmm', oldmat, t)
}

matrixsum <- function(mat1, mat2) {
    .Call('rarhsmm_matrixsum', PACKAGE = 'rarhsmm', mat1, mat2)
}

matrixintegral <- function(Q, interval, x, y) {
    .Call('rarhsmm_matrixintegral', PACKAGE = 'rarhsmm', Q, interval, x, y)
}

hsmm_hmm <- function(omega, dm, mv) {
    .Call('rarhsmm_hsmm_hmm', PACKAGE = 'rarhsmm', omega, dm, mv)
}

#' multinomial random variable generator
#' @param n number of random variables to generate
#' @param k number of categories
#' @param prob vector of probabilities summing up to 1
#' @param label vector of labels for each category
#' @return multinomial random variables
#' @export
rmultinomial <- function(n, k, prob, label) {
    .Call('rarhsmm_rmultinomial', PACKAGE = 'rarhsmm', n, k, prob, label)
}

#' multivariate normal random number generator
#' @param n number of random vectors to generate
#' @param mu vector of means
#' @param sigma variance-covariance matrix
#' @return a matrix with each row as a realization of multivariate normal random vector
#' @export
mvrnorm <- function(n, mu, sigma) {
    .Call('rarhsmm_mvrnorm', PACKAGE = 'rarhsmm', n, mu, sigma)
}

#' multivariate normal density
#' @param x matrix with each row as an observed vector of multivariate normal RVs
#' @param mean vector of means
#' @param sigma variance-covariance matrix
#' @param logd whether log transformation should be used
#' @return a vector of density values for each observed vector
#' @export
mvdnorm <- function(x, mean, sigma, logd) {
    .Call('rarhsmm_mvdnorm', PACKAGE = 'rarhsmm', x, mean, sigma, logd)
}

rgeometric <- function(n, pp) {
    .Call('rarhsmm_rgeometric', PACKAGE = 'rarhsmm', n, pp)
}

dgeometric <- function(x, pp, loga) {
    .Call('rarhsmm_dgeometric', PACKAGE = 'rarhsmm', x, pp, loga)
}

mvnhmm_gen <- function(n, M, d, prior, tpm, meanlist, sigmalist) {
    .Call('rarhsmm_mvnhmm_gen', PACKAGE = 'rarhsmm', n, M, d, prior, tpm, meanlist, sigmalist)
}

getnodeprob_nocov_mvn <- function(ystar, mean, sigma, m, p, arp, automat) {
    .Call('rarhsmm_getnodeprob_nocov_mvn', PACKAGE = 'rarhsmm', ystar, mean, sigma, m, p, arp, automat)
}

getnodeprob_part2 <- function(y, x, beta, mu, sigma, m, p) {
    .Call('rarhsmm_getnodeprob_part2', PACKAGE = 'rarhsmm', y, x, beta, mu, sigma, m, p)
}

forwardbackward <- function(Pi, P, nodeprob, dim, ntimes) {
    .Call('rarhsmm_forwardbackward', PACKAGE = 'rarhsmm', Pi, P, nodeprob, dim, ntimes)
}

hmmllk <- function(delta, gamma, nodeprob, y, ntimes, timeindex, missing) {
    .Call('rarhsmm_hmmllk', PACKAGE = 'rarhsmm', delta, gamma, nodeprob, y, ntimes, timeindex, missing)
}

hmmllk_cont <- function(delta, gamma, nodeprob, y, ntimes, timeindex) {
    .Call('rarhsmm_hmmllk_cont', PACKAGE = 'rarhsmm', delta, gamma, nodeprob, y, ntimes, timeindex)
}

fb_cont <- function(Pi, P, nodeprob, dim, ntimes, timeindex) {
    .Call('rarhsmm_fb_cont', PACKAGE = 'rarhsmm', Pi, P, nodeprob, dim, ntimes, timeindex)
}

